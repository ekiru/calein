import "prelude".
import "parser".
import "codegen".

define procedure (compile (tree)) to do {
	if ((tree) is an action) then {
		define variable (ir args) with initial value (false).
		define variable (args) with initial value (arguments of action (tree)).
		if ((name of action (tree)) is equal to "note")
			then (false)
		else (if ((name of action (tree)) is equal to "define record")
			then (make ir record (second ((args) at #0)))
		else (if ((name of action (tree)) is equal to "define procedure  to do")
			then (make ir procedure (second ((args) at #0))
				with body (compile (second ((args) at #1))))
		else (if ((name of action (tree)) is equal to "define variable  with initial value")
			then (make ir variable (second ((args) at #0))
				with initial value (compile (second ((args) at #1))))
		else (if ((name of action (tree)) is equal to "set  to")
			then (make ir assignment (second ((args) at #0))
				with value (compile (second ((args) at #1))))
		else (if ((name of action (tree)) is equal to "if  then  else")
			then (make ir if (compile (second ((args) at #0)))
				then (compile (second ((args) at #1)))
				else (compile (second ((args) at #2))))
		else (if ((name of action (tree)) is equal to "while  do")
			then (make ir while (compile (second ((args) at #0)))
				with body (compile (second ((args) at #1))))
		else (if (((name of action (tree)) is equal to "import") and (args)) then {
			if ((second ((args) at #0)) is a literal) then {
				define variable (file name) with initial value 
					(concat (value of literal (second ((args) at #0))) and ".cln").
				define variable (f) with initial value (open file (file name) for reading).
				define variable (import) with initial value
					(make ir import (ir of syntax trees (parse file (f)))).
				close file (f).
				import.
			} else (compile error "import takes only literal arguments.").
		} else {
			while (args) do {
				set (ir args) to ((compile (second (first (args)))), (ir args)).
				set (args) to (second (args)).
			}.
			make ir call (C ident for action (tree)) with arguments (reverse list (ir args)).
		}))))))).
	} else (if ((tree) is a sequence) then {
		define variable (ir items) with initial value (false).
		define variable (items) with initial value (items of sequence (tree)).
		while (items) do {
			set (ir items) to ((compile (first (items))), (ir items)).
			set (items) to (second (items)).
		}.
		make ir sequence (reverse list (ir items)).
	} else (if ((tree) is a number) then {
		make ir number (value of number (tree)).
	} else (if ((tree) is a literal) then {
		make ir literal (C string for literal (value of literal (tree))).
	} else (compile error "unsupported kind of tree")))).
}.

define procedure (ir of syntax trees (trees)) to do {
	define variable (irs) with initial value (false).
	while (trees) do {
		set (irs) to ((compile (first (trees))), (irs)).
		set (trees) to (second (trees)).
	}.
	reverse list (irs).
}.

define procedure (compile file (f)) to do {
	define variable (declarations) with initial value "".
	define variable (definitions) with initial value "".
	define variable (initializers) with initial value "".
	define variable (main) with initial value "".

	define variable (ir) with initial value (false).
	define variable (irs) with initial value (ir of syntax trees (parse file (f))).

	while (irs) do {
		set (ir) to (first (irs)).	
		if (ir) then {
			emit (ir) to (declarations) in (declaration context) with scope (global scope).
			emit (ir) to (definitions) in (definition context) with scope (global scope).
			emit (ir) to (initializers) in (initializer context) with scope (global scope).
			emit (ir) to (main) in (statement context) with scope (global scope).
		} else (false).
		set (irs) to (second (irs)).
	}.

	write line "#include \"caleinrtl.inc.c\"".
	write line (declarations).
	write line (definitions).
	(initializers), (main).
}.

define variable (main module)
with initial value (compile file (standard input)).

write line "int main() {".
write line "struct value *tmp_for_derefs = 0;\n".
write line (first (main module)).
write (second (main module)).
write line "return 0;".
write line "}".
